<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Daily Challenges | AutoNateAI Learning Hub</title>
  
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Space+Grotesk:wght@500;600;700&display=swap" rel="stylesheet">
  
  <!-- Critical styles -->
  <style>
    .dashboard { display: none !important; }
    .dashboard.ready { display: flex !important; }
    .auth-loading {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: #0a0a0f;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }
    .auth-loading.hidden { display: none; }
    .loading-content { text-align: center; color: #e8e8f0; }
    .loading-icon { font-size: 3rem; margin-bottom: 1rem; }
    .loading-spinner {
      width: 40px; height: 40px;
      border: 3px solid rgba(121, 134, 203, 0.3);
      border-top-color: #7986cb;
      border-radius: 50%;
      margin: 0 auto 1rem;
      animation: spin 0.8s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
  </style>
  
  <!-- Theme loader (before CSS to prevent flash) -->
  <script src="../shared/js/theme-loader.js"></script>

  <!-- Styles -->
  <link rel="stylesheet" href="../shared/css/dashboard.css">
  <link rel="stylesheet" href="../shared/css/challenge-puzzle.css">
  
  <!-- Firebase -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
  
  <!-- Cytoscape & Dagre -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.28.1/cytoscape.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dagre/0.8.5/dagre.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/cytoscape-dagre@2.5.0/cytoscape-dagre.min.js"></script>
  
  <!-- Anime.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
</head>
<body>
  
  <!-- Loading Screen -->
  <div class="auth-loading" id="auth-loading">
    <div class="loading-content">
      <div class="loading-icon">‚ö°</div>
      <div class="loading-spinner"></div>
      <p>Loading challenges...</p>
    </div>
  </div>
  
  <div class="dashboard" id="dashboard-content">
    
    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar">
      <a href="../index.html" class="sidebar-logo">
        <div class="logo-icon">üèõÔ∏è</div>
        <span class="logo-text">AutoNateAI</span>
      </a>
      
      <nav class="sidebar-nav">
        <div class="nav-section">
          <span class="nav-section-title">Main</span>
          <ul class="nav-list">
            <li class="nav-item">
              <a href="index.html" class="nav-link">
                <span class="nav-icon">üè†</span>
                <span class="nav-text">Dashboard</span>
              </a>
            </li>
            <li class="nav-item">
              <a href="courses.html" class="nav-link">
                <span class="nav-icon">üìö</span>
                <span class="nav-text">Course Library</span>
              </a>
            </li>
            <li class="nav-item">
              <a href="challenges.html" class="nav-link active">
                <span class="nav-icon">‚ö°</span>
                <span class="nav-text">Daily Challenges</span>
                <span class="nav-badge" id="challenges-remaining">3</span>
              </a>
            </li>
          </ul>
        </div>
        
        <div class="nav-section">
          <span class="nav-section-title">Learning</span>
          <ul class="nav-list">
            <li class="nav-item">
              <a href="progress.html" class="nav-link">
                <span class="nav-icon">üìä</span>
                <span class="nav-text">My Progress</span>
              </a>
            </li>
            <li class="nav-item">
              <a href="achievements.html" class="nav-link">
                <span class="nav-icon">üèÜ</span>
                <span class="nav-text">Achievements</span>
              </a>
            </li>
            <li class="nav-item">
              <a href="notes.html" class="nav-link">
                <span class="nav-icon">üìù</span>
                <span class="nav-text">Notes</span>
              </a>
            </li>
          </ul>
        </div>

        <div class="nav-section">
          <span class="nav-section-title">Community</span>
          <ul class="nav-list">
            <li class="nav-item">
              <a href="feed.html" class="nav-link">
                <span class="nav-icon">üì∞</span>
                <span class="nav-text">Feed</span>
              </a>
            </li>
            <li class="nav-item">
              <a href="https://discord.gg/Me5N8tCdkC" target="_blank" class="nav-link">
                <span class="nav-icon">üí¨</span>
                <span class="nav-text">Discord</span>
              </a>
            </li>
            <li class="nav-item">
              <a href="leaderboard.html" class="nav-link">
                <span class="nav-icon">üèÖ</span>
                <span class="nav-text">Leaderboard</span>
              </a>
            </li>
          </ul>
        </div>
        
        <div class="nav-section">
          <span class="nav-section-title">Account</span>
          <ul class="nav-list">
            <li class="nav-item">
              <a href="profile.html" class="nav-link">
                <span class="nav-icon">üë§</span>
                <span class="nav-text">Profile</span>
              </a>
            </li>
            <li class="nav-item">
              <a href="settings.html" class="nav-link">
                <span class="nav-icon">‚öôÔ∏è</span>
                <span class="nav-text">Settings</span>
              </a>
            </li>
            <li class="nav-item">
              <a href="#" class="nav-link" id="logout-link">
                <span class="nav-icon">üö™</span>
                <span class="nav-text">Sign Out</span>
              </a>
            </li>
          </ul>
        </div>
      </nav>
      
      <div class="sidebar-user">
        <div class="user-card" id="user-card">
          <div class="user-avatar" id="user-avatar">?</div>
          <div class="user-info">
            <div class="user-name" id="user-name">Loading...</div>
            <div class="user-streak">
              <span>üî•</span>
              <span id="user-streak">0</span> day streak
            </div>
          </div>
        </div>
      </div>
      
      <button class="sidebar-toggle" id="sidebar-toggle">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <polyline points="15 18 9 12 15 6"></polyline>
        </svg>
      </button>
    </aside>
    
    <!-- Mobile overlay -->
    <div class="sidebar-overlay" id="sidebar-overlay"></div>
    
    <!-- Main Content -->
    <main class="main-content">
      
      <!-- Header -->
      <header class="main-header">
        <div class="header-left">
          <button class="mobile-menu-btn" id="mobile-menu-btn">‚ò∞</button>
          <h1 class="page-title">Daily Challenges</h1>
        </div>
        
        <div class="header-right">
          <div class="header-actions">
            <button class="action-btn" title="Notifications">üîî</button>
          </div>
        </div>
      </header>
      
      <!-- Content -->
      <div class="content-area">
        
        <!-- Streak Display -->
        <div class="streak-display">
          <span class="streak-icon">üî•</span>
          <div class="streak-info">
            <div class="streak-count" id="streak-count">0 day streak</div>
            <div class="streak-label">Complete all 3 challenges to continue your streak!</div>
          </div>
          <div class="challenges-score">
            <span id="completed-count">0</span>/3
          </div>
        </div>
        
        <!-- Today's Date Header -->
        <div class="section-header">
          <h2 class="section-title" id="today-header">Today's Challenges</h2>
        </div>
        
        <!-- Challenges List -->
        <div class="challenges-list" id="challenges-list">
          <!-- Challenge cards will be inserted here -->
        </div>
        
      </div>
    </main>
    
  </div>
  
  <!-- Scripts -->
  <script src="../shared/js/firebase-config.js"></script>
  <script src="../shared/js/auth.js"></script>
  <script src="../shared/js/data-service.js"></script>
  <script src="../shared/js/interactive/diagram-utils.js"></script>
  <script src="../shared/js/interactive/audio-engine.js"></script>
  <script src="../shared/js/interactive/challenge-diagram.js"></script>
  <script src="../shared/js/interactive/challenge-puzzle.js"></script>
  
  <script>
    const today = new Date().toISOString().split('T')[0];
    
    // Challenge intro stories - multi-step with per-node audio narration
    const challengeIntros = {
      'ai-pipeline-intro': {
        id: 'ai-pipeline-intro',
        elements: [
          { data: { id: 'user', label: 'üë§ User', type: 'external' } },
          { data: { id: 'prompt', label: 'üìù Prompt', type: 'data' } },
          { data: { id: 'context', label: 'üìö Context', type: 'data' } },
          { data: { id: 'llm', label: 'ü§ñ LLM', type: 'service' } },
          { data: { id: 'output', label: '‚ú® Response', type: 'example' } },
          { data: { source: 'user', target: 'prompt' } },
          { data: { source: 'user', target: 'context' } },
          { data: { source: 'prompt', target: 'llm' } },
          { data: { source: 'context', target: 'llm' } },
          { data: { source: 'llm', target: 'output' } }
        ],
        steps: [
          { nodeId: 'user', caption: 'Everything begins with you - the user. Your intent, your question, your goal.' },
          { nodeId: 'prompt', edges: [{ from: 'user', to: 'prompt' }], caption: 'Your intent becomes a prompt - carefully crafted instructions that tell the AI what you need.' },
          { nodeId: 'context', edges: [{ from: 'user', to: 'context' }], caption: 'Context is the secret sauce. It gives the AI the background it needs to truly understand.' },
          { nodeId: 'llm', edges: [{ from: 'prompt', to: 'llm' }, { from: 'context', to: 'llm' }], caption: 'The large language model receives your prompt and context, processing them together.' },
          { nodeId: 'output', edges: [{ from: 'llm', to: 'output' }], caption: 'And out comes the response - shaped by how well you crafted the input. Now it\'s your turn to connect the flow!' }
        ]
      },
      'rag-pipeline-intro': {
        id: 'rag-pipeline-intro',
        elements: [
          { data: { id: 'query', label: '‚ùì Query', type: 'external' } },
          { data: { id: 'embed', label: 'üî¢ Embed', type: 'service' } },
          { data: { id: 'vectordb', label: 'üóÑÔ∏è Vector DB', type: 'data' } },
          { data: { id: 'docs', label: 'üìÑ Docs', type: 'data' } },
          { data: { id: 'llm', label: 'ü§ñ LLM', type: 'service' } },
          { data: { id: 'answer', label: 'üí° Answer', type: 'example' } },
          { data: { source: 'query', target: 'embed' } },
          { data: { source: 'embed', target: 'vectordb' } },
          { data: { source: 'vectordb', target: 'docs' } },
          { data: { source: 'query', target: 'llm' } },
          { data: { source: 'docs', target: 'llm' } },
          { data: { source: 'llm', target: 'answer' } }
        ],
        steps: [
          { nodeId: 'query', caption: 'It starts with a question - something you need answered using your own data.' },
          { nodeId: 'embed', edges: [{ from: 'query', to: 'embed' }], caption: 'Your query gets converted into a numerical vector - a mathematical representation of meaning.' },
          { nodeId: 'vectordb', edges: [{ from: 'embed', to: 'vectordb' }], caption: 'This vector searches a database of pre-embedded documents, finding the most similar matches.' },
          { nodeId: 'docs', edges: [{ from: 'vectordb', to: 'docs' }], caption: 'The most relevant documents are pulled out - your grounding context for the answer.' },
          { nodeId: 'llm', edges: [{ from: 'query', to: 'llm' }, { from: 'docs', to: 'llm' }], caption: 'The language model receives both your original query AND the retrieved documents together.' },
          { nodeId: 'answer', edges: [{ from: 'llm', to: 'answer' }], caption: 'The result? An answer grounded in your actual data - not hallucinated. Now wire up the RAG pipeline!' }
        ]
      },
      'agent-loop-intro': {
        id: 'agent-loop-intro',
        elements: [
          { data: { id: 'observe', label: 'üëÅÔ∏è Observe', type: 'concept' } },
          { data: { id: 'think', label: 'üß† Think', type: 'service' } },
          { data: { id: 'plan', label: 'üìã Plan', type: 'data' } },
          { data: { id: 'act', label: '‚ö° Act', type: 'example' } },
          { data: { id: 'tools', label: 'üîß Tools', type: 'external' } },
          { data: { id: 'memory', label: 'üíæ Memory', type: 'data' } },
          { data: { source: 'observe', target: 'think' } },
          { data: { source: 'think', target: 'plan' } },
          { data: { source: 'plan', target: 'act' } },
          { data: { source: 'act', target: 'tools' } },
          { data: { source: 'tools', target: 'memory' } },
          { data: { source: 'memory', target: 'observe' } }
        ],
        steps: [
          { nodeId: 'observe', caption: 'The agent begins by observing its environment - what\'s the current state of the world?' },
          { nodeId: 'think', edges: [{ from: 'observe', to: 'think' }], caption: 'With observations in hand, the agent thinks - reasoning about what it sees.' },
          { nodeId: 'plan', edges: [{ from: 'think', to: 'plan' }], caption: 'Thinking leads to planning - deciding the next steps to achieve the goal.' },
          { nodeId: 'act', edges: [{ from: 'plan', to: 'act' }], caption: 'The agent takes action, executing part of its plan.' },
          { nodeId: 'tools', edges: [{ from: 'act', to: 'tools' }], caption: 'Actions often use tools - APIs, databases, code execution - extending what the agent can do.' },
          { nodeId: 'memory', edges: [{ from: 'tools', to: 'memory' }], caption: 'Results get stored in memory, informing future decisions. And the loop continues! Now connect the cycle.' }
        ]
      }
    };
    
    // Today's puzzle challenges - using intro stories that have audio
    const todaysChallenges = [
      {
        id: 'ai-flow',
        type: 'connect-edges',
        category: 'ai-fundamentals',
        categoryLabel: 'AI FUNDAMENTALS',
        title: 'Connect the AI Pipeline',
        description: 'Connect the nodes to show how data flows from user input to AI output. Click two nodes to draw an edge between them.',
        instruction: 'Click a node to start, then click another to connect them.',
        xp: 50,
        introStory: 'ai-pipeline-intro', // Multi-step with per-node audio
        nodes: [
          { id: 'user', label: 'üë§ User Input' },
          { id: 'prompt', label: 'üìù Prompt' },
          { id: 'context', label: 'üìö Context' },
          { id: 'llm', label: 'ü§ñ LLM' },
          { id: 'output', label: '‚ú® Response' }
        ],
        nodeDescriptions: {
          'user': 'The human providing input to the system',
          'prompt': 'The formatted instruction sent to the AI',
          'context': 'Background information that helps the AI understand',
          'llm': 'The Large Language Model that processes everything',
          'output': 'The AI\'s generated response'
        },
        solution: {
          edges: [
            { source: 'user', target: 'prompt' },
            { source: 'user', target: 'context' },
            { source: 'prompt', target: 'llm' },
            { source: 'context', target: 'llm' },
            { source: 'llm', target: 'output' }
          ]
        }
      },
      {
        id: 'rag-flow',
        type: 'connect-edges',
        category: 'rag-systems',
        categoryLabel: 'RAG SYSTEMS',
        title: 'Build the RAG Pipeline',
        description: 'Retrieval Augmented Generation combines search with generation. Connect the nodes to show how RAG works!',
        instruction: 'Click nodes to connect them in the right order.',
        xp: 75,
        introStory: 'rag-pipeline-intro', // Multi-step with per-node audio
        nodes: [
          { id: 'query', label: '‚ùì Query' },
          { id: 'embed', label: 'üî¢ Embeddings' },
          { id: 'vectordb', label: 'üóÑÔ∏è Vector DB' },
          { id: 'docs', label: 'üìÑ Documents' },
          { id: 'llm', label: 'ü§ñ LLM' },
          { id: 'answer', label: 'üí° Answer' }
        ],
        nodeDescriptions: {
          'query': 'The user\'s question or search query',
          'embed': 'Converts text to numerical vectors',
          'vectordb': 'Database storing document embeddings',
          'docs': 'Retrieved relevant documents',
          'llm': 'Generates answer using retrieved context',
          'answer': 'The final grounded response'
        },
        solution: {
          edges: [
            { source: 'query', target: 'embed' },
            { source: 'embed', target: 'vectordb' },
            { source: 'vectordb', target: 'docs' },
            { source: 'query', target: 'llm' },
            { source: 'docs', target: 'llm' },
            { source: 'llm', target: 'answer' }
          ]
        }
      },
      {
        id: 'agent-loop',
        type: 'connect-edges',
        category: 'agentic-systems',
        categoryLabel: 'AGENTIC SYSTEMS',
        title: 'Wire the AI Agent Loop',
        description: 'AI agents observe, think, plan, act, and learn in a continuous loop. Connect the agent cycle!',
        instruction: 'Connect the nodes to create the agent reasoning loop.',
        xp: 100,
        introStory: 'agent-loop-intro', // Multi-step with per-node audio
        nodes: [
          { id: 'observe', label: 'üëÅÔ∏è Observe' },
          { id: 'think', label: 'üß† Think' },
          { id: 'plan', label: 'üìã Plan' },
          { id: 'act', label: '‚ö° Act' },
          { id: 'tools', label: 'üîß Tools' },
          { id: 'memory', label: 'üíæ Memory' }
        ],
        nodeDescriptions: {
          'observe': 'Perceive the current state of the environment',
          'think': 'Reason about observations using the LLM',
          'plan': 'Decide on the next steps to take',
          'act': 'Execute the planned action',
          'tools': 'External capabilities the agent can use',
          'memory': 'Store results for future reference'
        },
        solution: {
          edges: [
            { source: 'observe', target: 'think' },
            { source: 'think', target: 'plan' },
            { source: 'plan', target: 'act' },
            { source: 'act', target: 'tools' },
            { source: 'tools', target: 'memory' },
            { source: 'memory', target: 'observe' }
          ]
        }
      }
    ];
    
    let completedChallenges = new Set();
    
    // Render challenge card with split layout
    function renderChallengeCard(challenge, index) {
      const isComplete = completedChallenges.has(challenge.id);
      
      return `
        <div class="challenge-card ${isComplete ? 'complete' : ''}" 
             id="challenge-${challenge.id}"
             data-challenge-id="${challenge.id}">
          
          <div class="challenge-split">
            <!-- Left: Intro Video -->
            <div class="challenge-intro-side">
              <div class="challenge-number-badge">#${index + 1}</div>
              <h3 class="challenge-title">${challenge.title}</h3>
              <p class="challenge-description">${challenge.description}</p>
              
              <div class="challenge-video-container">
                <div class="challenge-diagram" id="intro-${challenge.id}" data-story="${challenge.introStory}"></div>
                <div class="challenge-caption"></div>
                <div class="video-controls">
                  <button class="video-play-btn" data-target="intro-${challenge.id}">
                    <span class="play-icon">‚ñ∂</span> Watch Intro
                  </button>
                  <button class="fullscreen-btn" data-fullscreen="video" data-challenge="${challenge.id}" title="Fullscreen">
                    ‚õ∂
                  </button>
                </div>
              </div>
              
              <div class="challenge-meta-bar">
                <span class="challenge-badge ${challenge.category}">${challenge.categoryLabel}</span>
                <span class="challenge-xp ${isComplete ? 'earned' : ''}">
                  ${isComplete ? '‚úì' : '+'} ${challenge.xp} XP
                </span>
              </div>
            </div>
            
            <!-- Right: Puzzle -->
            <div class="challenge-puzzle-side">
              <div class="puzzle-label">Your Turn: Connect the Flow</div>
              <div class="challenge-puzzle-area" id="puzzle-${challenge.id}"></div>
            </div>
          </div>
          
        </div>
      `;
    }
    
    // Initialize intro diagrams
    function initIntroDiagrams() {
      todaysChallenges.forEach(challenge => {
        const containerId = `intro-${challenge.id}`;
        const container = document.getElementById(containerId);
        if (!container) return;
        
        const story = challengeIntros[challenge.introStory];
        if (!story) return;
        
        // Use ChallengeDiagram for the intro animation
        if (window.ChallengeDiagram) {
          // Initialize audio engine for narration
          const audioEngine = new AudioNarrationEngine('../challenges/audio');
          
          const diagram = new ChallengeDiagram(containerId, story, {
            audioEngine,
            audioEnabled: true, // Enable audio narration
            canvasHeight: 180,
            autoPlay: false,
            showOverlay: false // We use external play button
          });
          
          // Store reference for external controls
          container._challengeDiagram = diagram;
        }
      });
    }
    
    // Initialize puzzles
    function initPuzzles() {
      todaysChallenges.forEach(challenge => {
        const containerId = `puzzle-${challenge.id}`;
        
        const puzzle = new ChallengePuzzle(containerId, challenge, {
          onComplete: (result) => {
            completedChallenges.add(challenge.id);
            updateCompletedCount();
            saveProgress(challenge.id, result);
            
            const card = document.querySelector(`[data-challenge-id="${challenge.id}"]`);
            if (card) {
              card.classList.add('complete');
              card.querySelector('.challenge-xp').classList.add('earned');
              card.querySelector('.challenge-xp').innerHTML = `‚úì ${challenge.xp} XP`;
            }
          }
        });
        
        // Store for fullscreen access
        window.puzzleInstances[challenge.id] = puzzle;
      });
    }
    
    // Initialize video play/pause controls
    function initVideoControls() {
      document.querySelectorAll('.video-play-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const targetId = btn.dataset.target;
          const container = document.getElementById(targetId);
          
          if (container && container._challengeDiagram) {
            const diagram = container._challengeDiagram;
            
            if (diagram.isPlaying) {
              // Pause
              diagram.pause();
              btn.innerHTML = '<span class="play-icon">‚ñ∂</span> Resume';
            } else {
              // Play
              btn.innerHTML = '<span class="play-icon">‚è∏</span> Playing...';
              
              // Set callback for when animation completes
              diagram.onComplete = () => {
                btn.innerHTML = '<span class="play-icon">‚Üª</span> Replay';
              };
              
              diagram.play();
            }
          }
        });
      });
    }
    
    function updateCompletedCount() {
      const count = completedChallenges.size;
      document.getElementById('completed-count').textContent = count;
      document.getElementById('challenges-remaining').textContent = 3 - count;
      
      if (count === 3) {
        document.querySelector('.streak-label').textContent = 'üéâ All challenges complete! Streak continued!';
      }
    }
    
    async function saveProgress(challengeId, result) {
      try {
        if (window.DataService?.recordChallengeCompletion) {
          await window.DataService.recordChallengeCompletion(challengeId, result);
        }
      } catch (e) {
        console.error('Error saving progress:', e);
      }
    }
    
    // Scroll to specific challenge from URL param
    function scrollToChallengeFromURL() {
      const params = new URLSearchParams(window.location.search);
      const challengeId = params.get('challenge');
      
      if (challengeId) {
        setTimeout(() => {
          const card = document.getElementById(`challenge-${challengeId}`);
          if (card) {
            card.scrollIntoView({ behavior: 'smooth', block: 'center' });
            // Highlight the card briefly
            card.style.boxShadow = '0 0 0 3px var(--accent-primary, #7986cb)';
            setTimeout(() => {
              card.style.boxShadow = '';
            }, 2000);
          }
        }, 500);
      }
    }
    
    // Initialize page
    document.addEventListener('DOMContentLoaded', async () => {
      const loadingScreen = document.getElementById('auth-loading');
      const dashboardContent = document.getElementById('dashboard-content');
      
      if (!window.FirebaseApp.init()) {
        console.error('Firebase initialization failed');
        loadingScreen.innerHTML = '<div class="loading-content"><p>Error loading. Please refresh.</p></div>';
        return;
      }
      
      window.AuthService.init();
      
      const user = await window.AuthService.waitForAuthState();
      
      if (!user) {
        window.AuthService.setRedirectUrl(window.location.href);
        window.location.href = '../auth/login.html';
        return;
      }
      
      loadingScreen.classList.add('hidden');
      dashboardContent.classList.add('ready');
      
      loadUserInfo(user);
      
      const dateOptions = { weekday: 'long', month: 'long', day: 'numeric' };
      document.getElementById('today-header').textContent = 
        `Today's Challenges ‚Äî ${new Date().toLocaleDateString('en-US', dateOptions)}`;
      
      // Render challenges
      const list = document.getElementById('challenges-list');
      list.innerHTML = todaysChallenges.map((c, i) => renderChallengeCard(c, i)).join('');
      
      // Initialize components
      setTimeout(() => {
        initIntroDiagrams();
        initPuzzles();
        initVideoControls();
        initFullscreenControls();
        scrollToChallengeFromURL();
      }, 150);
      
      await loadStreakData();
      
      setupSidebar();
      setupLogout();
      
      // Animate cards
      anime({
        targets: '.challenge-card',
        opacity: [0, 1],
        translateY: [30, 0],
        delay: anime.stagger(150),
        duration: 600,
        easing: 'easeOutCubic'
      });
      
      window.AuthService.onAuthStateChanged((user) => {
        if (!user) window.location.href = '../auth/login.html';
      });
    });
    
    function loadUserInfo(user) {
      const displayName = user.displayName || user.email.split('@')[0];
      document.getElementById('user-name').textContent = displayName;
      
      const avatar = document.getElementById('user-avatar');
      if (user.photoURL) {
        avatar.innerHTML = `<img src="${user.photoURL}" alt="Avatar">`;
      } else {
        avatar.textContent = displayName.charAt(0).toUpperCase();
      }
    }
    
    async function loadStreakData() {
      try {
        if (window.DataService) {
          const stats = await window.DataService.getUserStats();
          const streak = stats?.currentStreak || 0;
          document.getElementById('user-streak').textContent = streak;
          document.getElementById('streak-count').textContent = `${streak} day streak`;
        }
      } catch (e) {
        console.error('Error loading streak:', e);
      }
    }
    
    function setupSidebar() {
      const sidebar = document.getElementById('sidebar');
      const toggle = document.getElementById('sidebar-toggle');
      const overlay = document.getElementById('sidebar-overlay');
      const mobileBtn = document.getElementById('mobile-menu-btn');
      
      toggle?.addEventListener('click', () => {
        sidebar.classList.toggle('collapsed');
        localStorage.setItem('sidebarCollapsed', sidebar.classList.contains('collapsed'));
      });
      
      if (localStorage.getItem('sidebarCollapsed') === 'true') {
        sidebar.classList.add('collapsed');
      }
      
      mobileBtn?.addEventListener('click', () => sidebar.classList.add('open'));
      overlay?.addEventListener('click', () => sidebar.classList.remove('open'));
    }
    
    function setupLogout() {
      document.getElementById('logout-link')?.addEventListener('click', async (e) => {
        e.preventDefault();
        await window.AuthService.logout();
        window.location.href = '../index.html';
      });
    }
    
    // ============================================
    // Fullscreen Mode (Native Browser API)
    // ============================================
    
    function initFullscreenControls() {
      // Listen for fullscreen change events
      document.addEventListener('fullscreenchange', handleFullscreenChange);
      document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
      
      // Video fullscreen buttons
      document.querySelectorAll('.fullscreen-btn[data-fullscreen="video"]').forEach(btn => {
        btn.addEventListener('click', () => {
          const challengeId = btn.dataset.challenge;
          openVideoFullscreen(challengeId);
        });
      });
      
      // Add fullscreen buttons to puzzles after they render
      setTimeout(() => {
        todaysChallenges.forEach(challenge => {
          const puzzleControls = document.querySelector(`#puzzle-${challenge.id} .puzzle-controls`);
          if (puzzleControls && !puzzleControls.querySelector('.puzzle-fullscreen')) {
            const btn = document.createElement('button');
            btn.className = 'puzzle-btn puzzle-fullscreen';
            btn.innerHTML = '‚õ∂ Fullscreen';
            btn.addEventListener('click', () => openPuzzleFullscreen(challenge.id));
            puzzleControls.insertBefore(btn, puzzleControls.querySelector('.puzzle-check'));
          }
        });
      }, 300);
    }
    
    function openVideoFullscreen(challengeId) {
      const container = document.querySelector(`#intro-${challengeId}`).closest('.challenge-video-container');
      if (!container) return;
      
      container.dataset.challengeId = challengeId;
      container.dataset.fullscreenType = 'video';
      
      // Request native fullscreen
      if (container.requestFullscreen) {
        container.requestFullscreen();
      } else if (container.webkitRequestFullscreen) {
        container.webkitRequestFullscreen();
      }
    }
    
    function openPuzzleFullscreen(challengeId) {
      const puzzleArea = document.querySelector(`#puzzle-${challengeId}`);
      if (!puzzleArea) return;
      
      puzzleArea.dataset.challengeId = challengeId;
      puzzleArea.dataset.fullscreenType = 'puzzle';
      
      // Request native fullscreen
      if (puzzleArea.requestFullscreen) {
        puzzleArea.requestFullscreen();
      } else if (puzzleArea.webkitRequestFullscreen) {
        puzzleArea.webkitRequestFullscreen();
      }
    }
    
    function exitFullscreen() {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      } else if (document.webkitExitFullscreen) {
        document.webkitExitFullscreen();
      }
    }
    
    function handleFullscreenChange() {
      const fullscreenElement = document.fullscreenElement || document.webkitFullscreenElement;
      
      if (fullscreenElement) {
        // Entering fullscreen
        const challengeId = fullscreenElement.dataset.challengeId;
        const type = fullscreenElement.dataset.fullscreenType;
        
        fullscreenElement.classList.add('native-fullscreen');
        
        // Add exit button with clearer text
        if (!fullscreenElement.querySelector('.exit-fullscreen-btn')) {
          const exitBtn = document.createElement('button');
          exitBtn.className = 'exit-fullscreen-btn';
          exitBtn.innerHTML = '‚úï Exit Fullscreen';
          exitBtn.onclick = exitFullscreen;
          fullscreenElement.appendChild(exitBtn);
        }
        
        // Resize after entering fullscreen with viewport-aware padding
        setTimeout(() => {
          const viewportWidth = window.innerWidth;
          const viewportHeight = window.innerHeight;
          
          if (type === 'video') {
            const diagram = document.getElementById(`intro-${challengeId}`)?._challengeDiagram;
            if (diagram?.cy) {
              diagram.cy.resize();
              
              // Calculate padding based on viewport dimensions
              // Wider screens need more horizontal padding to keep diagram centered nicely
              const horizontalPadding = Math.max(80, viewportWidth * 0.12);
              const verticalPadding = Math.max(50, viewportHeight * 0.08);
              const padding = Math.max(horizontalPadding, verticalPadding);
              
              diagram.cy.fit(padding);
              diagram.cy.center();
            }
          } else if (type === 'puzzle') {
            const puzzleInstance = window.puzzleInstances?.[challengeId];
            if (puzzleInstance?.cy) {
              puzzleInstance.cy.resize();
              // Puzzles can use more space
              const padding = Math.max(40, Math.min(viewportWidth, viewportHeight) * 0.06);
              puzzleInstance.cy.fit(padding);
              puzzleInstance.cy.center();
            }
          }
        }, 100);
      } else {
        // Exiting fullscreen - find element that was fullscreen and reset it
        const wasFullscreen = document.querySelector('.native-fullscreen');
        if (wasFullscreen) {
          const challengeId = wasFullscreen.dataset.challengeId;
          const type = wasFullscreen.dataset.fullscreenType;
          
          // Remove exit button first
          const exitBtn = wasFullscreen.querySelector('.exit-fullscreen-btn');
          if (exitBtn) exitBtn.remove();
          
          // Remove fullscreen class
          wasFullscreen.classList.remove('native-fullscreen');
          
          // Clear any inline styles that might have been set during fullscreen
          const clearInlineStyles = (element) => {
            if (!element) return;
            // Clear common inline styles that might persist
            element.style.width = '';
            element.style.height = '';
            element.style.position = '';
            element.style.top = '';
            element.style.left = '';
            element.style.right = '';
            element.style.bottom = '';
            
            // Also clear Cytoscape's canvas container
            const cyContainer = element.querySelector('[style*="width"]');
            if (cyContainer) {
              cyContainer.style.width = '';
              cyContainer.style.height = '';
            }
          };
          
          // Force proper reset
          const resetCytoscape = (cy, containerEl, padding) => {
            // Clear any inline styles on the container
            clearInlineStyles(containerEl);
            
            // Force Cytoscape to recalculate dimensions
            cy.resize();
            
            // Reset zoom and pan
            cy.zoom(1);
            cy.pan({ x: 0, y: 0 });
            
            // Fit to container
            cy.fit(padding);
            cy.center();
          };
          
          // Use setTimeout for more reliable timing after fullscreen exit
          setTimeout(() => {
            if (type === 'video') {
              const diagramEl = document.getElementById(`intro-${challengeId}`);
              const diagram = diagramEl?._challengeDiagram;
              if (diagram?.cy) {
                resetCytoscape(diagram.cy, diagramEl, 20);
                // Final check
                setTimeout(() => {
                  diagram.cy.resize();
                  diagram.cy.fit(20);
                }, 50);
              }
            } else if (type === 'puzzle') {
              const puzzleCanvas = document.querySelector(`#puzzle-${challengeId} .puzzle-canvas`);
              const puzzleInstance = window.puzzleInstances?.[challengeId];
              if (puzzleInstance?.cy) {
                resetCytoscape(puzzleInstance.cy, puzzleCanvas, 25);
                // Final check
                setTimeout(() => {
                  puzzleInstance.cy.resize();
                  puzzleInstance.cy.fit(25);
                }, 50);
              }
            }
          }, 100);
        }
      }
    }
    
    // Store puzzle instances globally for fullscreen access
    window.puzzleInstances = {};
  </script>
</body>
</html>
